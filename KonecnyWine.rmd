EXPLORING WINE QUALITY by STEFAN KONECNY
========================================================

```{r echo=FALSE, message=FALSE, warning=FALSE, packages}
# Load all of the packages that you end up using in your analysis in this code
# chunk.

# Notice that the parameter "echo" was set to FALSE for this code chunk. This
# prevents the code from displaying in the knitted HTML output. You should set
# echo=FALSE for all code chunks in your file, unless it makes sense for your
# report to show the code that generated a particular plot.

# The other parameters for "message" and "warning" should also be set to FALSE
# for other code chunks once you have verified that each plot comes out as you
# want it to. This will clean up the flow of your report.

library(ggplot2)
library(gridExtra)
#library(scales)
#library(GGally)
```

This data contains information about quality of (Vinho Verde) white wines from Minho region (in Portugal). It contains objective measurements of 11 chemical attributes of 4898 different white wines along with a quality score. The data set is tidy and complete i.e. there are no data entries missing.

The quality score is median value from an expert jury with at least three judges. It would be very interesting to have also the scores of individual judges, so I could see the variance in scores. Unfortunately only the aggregate value is provided.

Quality takes a numerical value, but it is effectively an ordered factor (and is treated accordingly). According to [dataset description](https://s3.amazonaws.com/udacity-hosted-downloads/ud651/wineQualityInfo.txt) possible values for quality range from 0 (very bad) and 10 (very excellent). The [academic paper](https://www.researchgate.net/publication/222430341_Modeling_wine_preferences_by_data_mining_from_physicochemical_properties) [1] referencing the dataset suggests that expert judged the wine on this numeric scale (as opposed to a qualitative scale later mapped to numbers). 

# Univariate Plots Section

```{r echo=FALSE}
#Load the Data
#sum(complete.cases(wines_w))
wines_w <-read.csv('wineQualityWhites.csv')

##add new variables

wines_w$rating <- wines_w$quality
#wines_w$num_quality <- wines_w$quality

#cast quality into ordered factor
#wines_w$quality <- ordered(wines_w$quality)

#create rating which has broader categories 4 instead of 10
wines_w$rating <- ordered(cut(wines_w$rating, c(0,4,6,7,10), 
                             labels = c('bad','medium','good','excelent')))

#check whether it worked
#head(wines_w[c("rating","quality")],30)

#creating new ratio variable
wines_w$ratio.sulfur.dioxide<-wines_w$free.sulfur.dioxide/wines_w$total.sulfur.dioxide
```


```{r echo=FALSE, Univariate_Plots_Quality}
#Draw a histogram of quality color coded by rating
#show_leg tells whether legend should be shown (for matrix of plots)
#show_all_hist shows dashed histogram of the original dataset (used in conjunction with filtered datasets)

quality_bar<-function(title, data1 = wines_w, show_leg = FALSE, show_all_hist = FALSE){
  p1<-ggplot(aes(x = quality, fill = rating), data = data1) +
  geom_bar() +
  xlab('Quality') +
  ylab('Count')+
  ggtitle(title)
  
  #remove legend,
  if(!show_leg){
    p1<-p1+theme(legend.position="none")
  }
  
  if(show_all_hist){
    p1<-p1+geom_bar(color = 'red', fill = NA, linetype="dashed", data = wines_w)
  }

  return(p1)
}

p1 <-quality_bar("Name", show_all_hist = FALSE)
p1
```

```{r, echo=FALSE}
g <- ggplot_build(p1)
used_cols<-unique(g$data[[1]]["fill"])[[1]]
```

Quality and Rating are the only two factor variables. The remaining variables are numerical.

According to the dataset description numerical variables can be divided into:

1. those measured on a normalized scale: pH and alcohol
2. those measured in weight per volume: the rest
    + some of these values my depend on each other, such as free and total sulfur dioxide
    
The value range for all variables is quite narrow and similar for all ratings. The distributions don't have a significant long tail as they had with diamond prices or facebook friend counts.

Let me start with factoring alcohol and pH through rating. Will set the scale to 'free_y' so the less frequent rating are not flattened.

```{r echo=FALSE, message = FALSE, Univariate_Plots_Alcohol_facet_Rating}

ggplot(aes(x = alcohol, fill = rating), data = wines_w) +
  geom_histogram(color = 'gray') +
  facet_wrap(~rating) 


ggplot(aes(x = alcohol, fill = rating), data = wines_w) +
  geom_histogram(color = 'gray') +
  facet_wrap(~rating, scale = 'free_y') 
```

```{r echo=FALSE,  message = FALSE, Univariate_Plots_pH_facet_Rating}
ggplot(aes(x = pH, fill = rating), data = wines_w) +
  geom_histogram(color = 'gray') +
  facet_wrap(~rating, scale = 'free_y') 
```

## Investigating individual variables

###General trends

I investigated all the variables with the function bellow. In general histograms showed a similar trends and (seemingly) normal distribution. On the other hand Boxplots and Summaries of some variables revealed some interesting trends.

Boxplot and Summaries show tha medium (rating) wines typically exhibit the most variance (and most outliers). Since medium is the most frequent category, it is not surprising. Conversely excelent wines are rare and generally have the lowest variance.

```{r echo=FALSE, Univariate_Plots_Variable_facet_Rating}

explore_var <- function(var1, data1 = wines_w){
  #histograms 
  h1<-ggplot(aes(x = var1, fill = rating), data = data1 )+
  geom_histogram(color = 'gray') +
  facet_wrap(~rating, scales = "free_y")+
  #only use the part after $
  ylab(strsplit(deparse(substitute(var1)),"\\$")[[1]][2])

  
  # boxplot
  b1<-ggplot(aes(y = var1, x= rating), data = data1)+
  geom_boxplot()+
  
  #only use the part after $ for label name
  ylab(strsplit(deparse(substitute(var1)),"\\$")[[1]][2])+
  stat_summary(fun.y=mean, colour="red", geom="point", size=2)
  
  #summary
  s1<-by(var1,wines_w$rating, summary)

  return(list(h1,b1,s1))
}
```


```{r echo=FALSE}
res_var <-explore_var(wines_w$chlorides)
```

Notes:

Alcohol - similar trends but bad and medium wines are skewed towards lower aclohol content

pH - very similar trends, no outliers for excelent wines

volatile.acidity - higher for bad wines (check summary)

chlorides - higher for bad wines (check summary), very cool strong trend 1,2,3Q + mean drops with rating

free.sulfur.dioxide - could be used to prune bad wines? (check summary)

free/total.sulfur - could be used to prune bad wines, very cool strong trend 1,2,3Q + mean grows with rating

density - higher for bad wines (check summary)

alcohol - lower for bad wines

Some of the variable considered below revealed interesting trends. Namely **chlorides**, **ratio between free.sulfur.dioxide and total.sulfur.dioxide** and **density**. These trends can be spotted in boxplots and become clearly visible in statistical summary.

###Chlorides
 
```{r echo=FALSE}
res_var[[2]]
```

This plot suggests that the median for good and excellent wines is less the the first quartile for medium and bad wines. This means that good wines are statistically more likely to have lower value of chlorides then bad ones. The summary confirms this.

```{r echo=FALSE}
res_var[[3]]
```

So if I would discard all wines with chlorides above 0.03700 (the median for good wines), I would discard majority of bad and medium wines and still keep a significant proportion of good and excellent ones.

If I decide to focus exclusively on excellent wines, I can go even tighter and remove wines with chlorides above 0.0355 (median for excellent wines).

Another observation is that value for all quartiles and the mean decrases with rating. So there is a strong trend there.

###Ratio between free.sulfur.dioxide and total.sulfur.dioxide

For free.sulfur.dioxide boxplot reveals a promise of a trend allowing me to discard some bad wines.

```{r echo=FALSE}
explore_var(wines_w$free.sulfur.dioxide)[[2]]
```

Interesting the ratio of free and total sulfur dioxide reveals an even clearer trend. This is true despite of the total sulfur dioxide not showing a strong trend on its own.

```{r echo=FALSE}
explore_var(wines_w$free.sulfur.dioxide)[[2]]

explore_var(wines_w$total.sulfur.dioxide)[[2]]

explore_var(wines_w$ratio.sulfur.dioxide)[[2]]
```

Once again I validate this insight by inspecting the the statistical summary.

```{r echo=FALSE}
explore_var(wines_w$ratio.sulfur.dioxide)[[3]]
```

In this case median of good wines is above the 3rd Quartile of bad wines. And this allows me to filter out large majority of bad wines. 

Similarly to the chlorides all Quartiles and the mean follow a clear (this time growing) trend with the rating. 

###Density

I did the same analysis for density.

```{r echo=FALSE}
explore_var(wines_w$density)[[3]]
```

This time median for good and excellent wines is bellow the first quartile for medium and bad ones. So I can again discard some medium and bad wines as with chlorides.

In this case the quantiles and mean do not follow a clear trend w.r.t to rating.

###Alcohol

```{r echo=FALSE}
explore_var(wines_w$alcohol)[[3]]
```

Alcohol content almost follows a growing trend for quantiles and mean w.r.t ratio. I decided not to filter out wines with low alcohol content, since alcohol content is typically known to the consumer (unlike the other investigated variables). Hence  removing wines with low alcohol volume may reduce choices for consumer with this preference.

###Filtering

Based on the above observation I have created a filtered dataset. I kept wines with following properties:

1. chlorides < 0.037 (median for good wines)
2. ratio.sulfur.dioxide > 0.2717 (median for good wines)
3. density < 0.9918 (median for good wines)
4. alcohol > 11.00 (3Q for medium) - NOT USED.

The filtered data set contains 374 wines, which represent 7.63% of the original dataset of 4898 wines.

```{r echo=FALSE, Filter_Variables}
#names(wines_w)

filter_data <- function(exp1, data1 = wines_w, verbose = FALSE){
  data2 <-subset(data1,eval(exp1))
  
  #printout reduction
  if(verbose){
    t1<-table(data1$quality)
    t2<-table(data2$quality)
  
    dif <-t2/t1
    print(dif)
  }
  
  return(data2)
}
```

More importantly the distribution of the rating changed significantly as apparent from this grid plot. The dashed shape in the backgound shows the barplot with all the wines (before filtering).


```{r echo=FALSE}
#filter_data(quote(wines_w$chlorides<0.037),verbose = TRUE)

#before filtering
p0 <-quality_bar("All")

draw_siluette = TRUE

#filter chlorides <0.037 <0.0355
filtered_wines_w<-filter_data(quote(chlorides<0.037))
fw<-filter_data(quote(chlorides<0.037))
p1 <- quality_bar("Chlorides", fw, show_all_hist = draw_siluette)

#filter ratio.sulfur.dioxide>0.2717
filtered_wines_w<-filter_data(quote(ratio.sulfur.dioxide>0.2717), data = filtered_wines_w)
fw<-filter_data(quote(ratio.sulfur.dioxide>0.2717))
p2 <- quality_bar("Sulf Ratio", fw, show_all_hist = draw_siluette)

#filter density <0.9918 0.9916
filtered_wines_w <-filter_data(quote(density<0.9918), data = filtered_wines_w)

fw<-filter_data(quote(density<0.9918))

p3 <- quality_bar("Density", fw, show_all_hist = draw_siluette)

p4 <- quality_bar("Filtered", fw, show_all_hist = draw_siluette)


grid.arrange(p0, p1, p2, p3, p4, ncol=2)


#table(wines_w$rating)/length(wines_w$rating)
#table(filtered_wines_w$rating)/length(filtered_wines_w$rating)

#print("All wines")
#table(wines_w$quality)/length(wines_w$quality)

#print("After Filtering")
#table(filtered_wines_w$quality)/length(filtered_wines_w$quality)

#table(wines_w$quality)
#table(filtered_wines_w$quality)

#removed

#print("Wines Filtered Out")
#(table(wines_w$quality) - table(filtered_wines_w$quality))/table(wines_w$quality)
```

Distribution of wines before filtering

```{r echo=FALSE}
table(wines_w$quality)/length(wines_w$quality)
```

Distribution of wines after filtering

```{r echo=FALSE}
table(filtered_wines_w$quality)/length(filtered_wines_w$quality)
```

The original distribution is in the top left bar plot and the filtered one is in the bottom left one. The ratio of < 6 wines (short for wines with quality 6 and below) is much smaller. Wines with the lowest quality 3 were completely removed. The most frequent quality is now 7 (44.4%), whereas originally it was  6 (with 44.9%).

More then 98.5% of < 6 wines were removed. 93% of 6's were removed in contrast to only 81% / 82% for 7/8's and only 40% of 9's.

Therefore there is a higher ratio of wines of above 6 (good and excellent, 53.75%) then below 7 (medium and bad, 46.25%).

Because there is now similar number of 6's and 7's left it will be easier to spot differences and commonalities between the two groups.

###Impact of filtering

```{r echo=FALSE}
#this a bit hacky, I create a new data frame with adding the
#filtered wines to be able to do before/after boxplots

wines_w$filtering = 'all'
filtered_wines_w$filtering = 'filtered'

baf_wines_w <- rbind(wines_w,filtered_wines_w)
```

```{r echo=FALSE}
explore_filtering <- function(var1, data1 = baf_wines_w, f1 = 'filtered'){
  
  #caculate the range in y for the filtered only
  dataf1 <-var1[data1$filtering == f1]
  r1 <- range(dataf1)
  
  #even tighter range between whiskers
  iqr1 <- IQR(dataf1)
  r2 <- c(median(dataf1)- 2*iqr1, median(dataf1)+ 2*iqr1)
  
  p1<-ggplot(aes(y = var1, x= filtering), data = data1)+
    geom_boxplot()+
    #only use the part after $
    ylab(strsplit(deparse(substitute(var1)),"\\$")[[1]][2])+
    stat_summary(fun.y=mean, colour="red", geom="point",
                 size=2)+
    coord_cartesian(ylim=r2)+
    facet_wrap(~rating)
  
  p2<-ggplot(aes(y = var1, x= rating), data = data1)+
    geom_boxplot()+
    #only use the part after $
    ylab(strsplit(deparse(substitute(var1)),"\\$")[[1]][2])+
    stat_summary(fun.y=mean, colour="red", geom="point",
                 size=2)+
    coord_cartesian(ylim=r1)+
    facet_wrap(~filtering)
  
  p3<-ggplot(aes(y = var1, x= rating), data = data1)+
    geom_boxplot()+
    #only use the part after $
    ylab(strsplit(deparse(substitute(var1)),"\\$")[[1]][2])+
    stat_summary(fun.y=mean, colour="red", geom="point",
                 size=2)+
    coord_cartesian(ylim=r2)+
    facet_wrap(~filtering)
  
  return(list(p1,p2,p3))
}
```

Next I have re-examined the variables again, this time considering only the filtered wines. I was curious whether new trends have emerged. This is indeed the case. The most pronounced trend can be observed for residual sugar.

####Residual sugar

```{r echo=FALSE}
#can discriminate between excellent good and bad
explore_filtering(baf_wines_w$residual.sugar)[[3]]+
  geom_hline(yintercept = 2.6, color = "blue", linetype="dotted")+
  geom_hline(yintercept = 4.212, color = "green", linetype="dotted")
by(filtered_wines_w$residual.sugar,filtered_wines_w$rating, summary)

#disciminates excellent vs good removes all bead and half medium
#volatile.acidity > 0.2700 (1Q excellent)
# explore_filtering(baf_wines_w$volatile.acidity)[3]
# by(filtered_wines_w$volatile.acidity,filtered_wines_w$rating, summary)

#discriminates excellent vs good removes all the bad wines but leaves medium
# explore_filtering(baf_wines_w$citric.acid)[3]
# by(filtered_wines_w$citric.acid,filtered_wines_w$rating, summary)

#removes medium and bad wines below 3Q Bad
# explore_filtering(baf_wines_w$total.sulfur.dioxide)[3]
# by(filtered_wines_w$total.sulfur.dioxide,filtered_wines_w$rating, summary) 
```

Once again I could remove majority (more then 75%) of wines < 5 while certainly keeping at least 50% of remaining > 6 wines. To do this, I would need to remove all wines with residual sugar > 2.6 (3Q for medium wines, blue dotted line).

In the first round of filtering the aim was to remove bulk of bad and medium wines. Now I have more control. I could also use residual sugar to separate good and excellent wines by keeping only wines with residual sugar above 4.212 (3Q good, green dotted line).

####Options for further filtering

Besides residual sugar, I could use value of total.sulfur.dioxide > 113.8 to remove majority of bad and medium wines

```{r echo=FALSE}
explore_filtering(baf_wines_w$total.sulfur.dioxide)[[3]]+
  geom_hline(yintercept = 113.8, color = "blue", linetype="dotted")
```

Or use the value of citric.acid > 0.3375 to separate good and excellent wines (after I removed the medium wines through residual sugar or total sulfur dioxide value).

```{r echo=FALSE}
explore_filtering(baf_wines_w$citric.acid)[[3]]+
  geom_hline(yintercept = 0.3375, color = "blue", linetype="dotted")
```

Alcohol remains a promising candidate for removing most bad and medium wines, while keeping at least the half of excellent ones.

```{r echo=FALSE}
explore_filtering(baf_wines_w$alcohol)[[3]]+
  geom_hline(yintercept = 12.4, color = "blue", linetype="dotted")
```


In summary I have many more options for additional filtering:

1. residual.sugar > 2.6 (3Q medium) or > 4.212 (3Q good)
2. total.sulfur.dioxide > 113.8 (3Q bad > 3Q medium)
3. alcohol > 12.4 (3Q medium)
4. citric.acid > 0.3375 (3Q good)
 
The trends in the filtered wines appear much clearer. They also allow for filtering not only medium wines but even to reduce the proportion between good an excellent ones.

However I was not able to complete remove bad wines with simple pruning described above. If I apply all the filtering steps simultaneously, there would only 9 wines left: 5 bad, 2 medium and 2 excellent. But if I skip the citric acid step, I will have 5 bad, 11 medium and 6 excellent. The latter distribution is seems much more promising.

```{r echo=FALSE}
fw1 <- filter_data(quote(residual.sugar > 4.212 & total.sulfur.dioxide > 113.8 &
                          alcohol > 12.4), data = filtered_wines_w)
p1 <- quality_bar("No C.A.", fw1)
p1 <- p1+geom_bar(color = 'green', fill = NA, linetype="dashed", data = fw1)
p1 <- p1+scale_fill_manual(values = used_cols[2:4])

fw0 <- filter_data(quote(citric.acid > 0.3375), data = fw1)
p0  <- quality_bar("All", fw0)
p0  <- p0+geom_bar(color = 'green', fill = NA, linetype="dashed", data = fw1)
p0  <- p0+scale_fill_manual(values = used_cols[2:4])

grid.arrange(p0, p1, ncol=2)
```




Next I would like investigate how much filtering reduces the variety of wines. I will do that by drawing bi- and multivariate plots.

```{r echo=FALSE, Filtering_Wines_Stage_II}
#filter 
#filtered2_wines_w<-filter_data(quote(residual.sugar > 2.6), data = filtered_wines_w)
fw <- filter_data(quote(residual.sugar > 2.6), data = filtered_wines_w)
p1 <- quality_bar("Residual Sugar", fw)
p1 <- p1+geom_bar(color = 'green', fill = NA, linetype="dashed", data = filtered_wines_w)

filtered2_wines_w<-filter_data(quote(residual.sugar > 4.212), data = filtered_wines_w)
fw <- filter_data(quote(residual.sugar > 4.212), data = filtered_wines_w)
p2 <- quality_bar("Residual Sugar", fw)
p2 <- p2+geom_bar(color = 'green', fill = NA, linetype="dashed", data = filtered_wines_w)

#SULFUR
filtered2_wines_w<-filter_data(quote(total.sulfur.dioxide > 113.8), data = filtered2_wines_w)
#filtered2_wines_w<-filter_data(quote(total.sulfur.dioxide > 113.8), data = filtered_wines_w)
fw <- filter_data(quote(total.sulfur.dioxide > 113.8), data = filtered_wines_w)
p3 <- quality_bar("T. S. D.", fw)
p3 <- p3+geom_bar(color = 'green', fill = NA, linetype="dashed", data = filtered_wines_w)

#CITRIC ACID
#filtered2_wines_w<-filter_data(quote(citric.acid > 0.3375), data = filtered2_wines_w)
fw <- filter_data(quote(citric.acid > 0.3375), data = filtered_wines_w)
p4 <- quality_bar("Citric Acid", fw)
p4 <- p4+geom_bar(color = 'green', fill = NA, linetype="dashed", data = filtered_wines_w)

#ALCOHOL
filtered2_wines_w<-filter_data(quote(alcohol > 12.40), data = filtered2_wines_w)
fw <- filter_data(quote(alcohol > 12.40), data = filtered_wines_w)
p5 <- quality_bar("Alcohol", fw)
p5 <- p5+geom_bar(color = 'green', fill = NA, linetype="dashed", data = filtered_wines_w)

p6 <- quality_bar("RS+CA", filtered2_wines_w)
#p6 <- p6+geom_bar(color = 'green', fill = NA, linetype="dashed", data = filtered_wines_w)
```

# Univariate Analysis

### What is the structure of your dataset?

There is one dependent variable quality describing the quality of the wine. The remaining variables are results of various chemical measurements. These variables all seem to follow normal distribution.

### What is/are the main feature(s) of interest in your dataset?

Main feature of interest is clearly the quality of wine. This variable is effectively a ranking ranging from 0 (very bad) and 10 (very excellent). This dataset contains only wines with quality between 3 and 9. However there are only very few wines of quality 3 and 9, and the most wines has the the quality 6, 5 and 7.

```{r}
table(wines_w$quality)
```


The interesting question is how is quality determined by the other variables.

### What other features in the dataset do you think will help support your \
investigation into your feature(s) of interest?

I have identified a number of variables (and their critical values) which allow me to distinguish wines >= 7 (quality 7 is good, 8 and 9 is excellent) from medium (5 and 6) and bad wines (below 5).

1. chlorides < 0.037 (median for good wines)
2. ratio.sulfur.dioxide > 0.2717 (median for good wines)
3. density < 0.9918 (median for good wines)
4. alcohol > 11.00 (3Q for medium) - NOT USED.

I found the variables and values by inspecting the boxplots and looking at statistical summaries. By removing wines not meeting those characteristics (except alcohol) I have obtained a much smaller dataset of 374 wines (7.63% of total). In the filtered dataset the majority of wines is good  or excellent (44.39% and 9.36%). These proportions were much smaller in the original dataset (17.97% and 3.67%). This shows that the majority of bad and medium wines was removed.

Repeating the analysis for filtered wines, I identified more options for filtering:

1. residual.sugar > 2.6 (3Q medium) or > 4.212 (3Q good)
2. total.sulfur.dioxide > 113.8 (3Q bad > 3Q medium)
3. alcohol > 12.4 (3Q medium)
4. citric.acid > 0.3375 (3Q good)

Experimenting with these additional step I ended up with only 17 wines: 5 bad, 11 medium and 6 excellent.

### Did you create any new variables from existing variables in the dataset?

Yes. I created an ordered factor rating witch is a simplified version of quality I have use ford plotting. The possible values are bad (quality 3,4), medium (quality 5,6), good (quality 7) and excellent (quality 8,9).

I introduced ratio.sulfur.dioxide which a numeric variable whose value is free.sulfur.dioxide / total.sulfur.dioxide

I also introduced an auxiliary variable filtering to draw before/after boxplots.

# Bivariate Plots Section

I have plotted the various variables (e.g. sulphates) against quality in scatterplots. To remove outliers I have plotted only values which fell into the interval [median - 2\*IQR, median + 2\*IQR] (within the whiskers for boxplot). I also plotted the some statistical summaries among the datapoints: median (red dot) and 1st and 3 quantile (blue dots). The datapoints were coloured according to their rating.

In general scatterplots revealed more structure but mostly confirmed observations from boxplots. Take for example sulpahtes.

```{r echo=FALSE}
qwrap <- function(x,num){
  return(quantile(x,probs = c(num))[[1]])
}

plot_vs_quality <- function(var1, data1 = wines_w, alpha1 = 0.25, show_leg = FALSE){
  #calculate the range between whiskers to plot
  iqr1 <- IQR(var1)
  md1 <- median(var1)
  r1 <- c(md1- 2*iqr1, md1+ 2*iqr1)

  p1 <- ggplot(aes(x = quality, y = var1, color = rating),
                    data= data1)+
               geom_point(alpha = alpha1, position = position_jitter(h=0))+
               stat_summary(fun.y=median, colour="red", geom="point", size=2)+
               stat_summary(fun.y=qwrap, fun.args = list(c(0.25)),
                            colour="blue", geom="point", size=2)+
               stat_summary(fun.y=qwrap, fun.args = list(c(0.75)),
                            colour="blue", geom="point", size=2)+
               coord_cartesian(ylim = r1)+
               #only use the part after $ for label name
               ylab(strsplit(deparse(substitute(var1)),"\\$")[[1]][2])
  
  #remove legend
  if(!show_leg){
    p1<-p1+theme(legend.position="none")
  }

  return(p1)
}

# nw <- names(wines_w)
# scope <- c(2:12,15)
# 
# res <- list()
# index <- 1
# 
# for(i in scope){
#   pi <- plot_vs_rating(wines_w[, i])+
#     ylab(nw[i])
#   
#   res <- list(res,pi)
# }

plot_vs_quality(wines_w$sulphates)
```

The majority of wines is of quality 5 to 7. There appears no clear pattern linking suplhates to the quality (and therefore rating). This is the case for most variables apart from few exceptions.

The exceptions are the same I have identified from boxplots:

1. chlorides < 0.037 (median for good wines)
2. ratio.sulfur.dioxide > 0.2717 (median for good wines)
3. density < 0.9918 (median for good wines)
4. alcohol > 11.00 (3Q for medium) - NOT USED.

```{r echo=FALSE}
p1 <- plot_vs_quality(wines_w$chlorides)
p1 <- p1 + geom_hline(yintercept = 0.037, color = "blue", linetype="dotted")

p2 <- plot_vs_quality(wines_w$ratio.sulfur.dioxide)
p2 <- p2 + geom_hline(yintercept = 0.2717, color = "blue", linetype="dotted")

p3 <- plot_vs_quality(wines_w$density)
p3 <- p3 + geom_hline(yintercept = 0.9918, color = "blue", linetype="dotted")

p4 <- plot_vs_quality(wines_w$alcohol)
p4 <- p4 + geom_hline(yintercept = 11.0, color = "blue", linetype="dotted")


grid.arrange(p1, p2, p3, p4, ncol=2)
```

There is one more interesting case volatile acidity. In hindsight the trend was apparent in the boxplot/summary as well. But when I looked at the boxplot I was focused on discriminating bad and medium wines from good an excellent (as opposed to removing bad ones). 

Anyhow adding filtering by volatile acidity would not improving filtering. Actually it would make things much worse. Removing wines through filtering is very delicate trial and error procedure. One has to be carefull not to remove too many wines.

```{r}
p1 <- plot_vs_quality(wines_w$volatile.acidity)
p1 <- p1 + geom_hline(yintercept = 0.26, color = "blue", linetype="dotted")
p1
```

I have also calculated the Pearson's R between quality and the other variables. Interestingly the four variables with the strongest correlation (in a absolute terms) are the same I have found through box plot investigation:

1. alcohol
2. density
3. chlorides
4. ratio.sulfur.dioxide

```{r echo=FALSE}
cor_all <-cor(wines_w[13],wines_w[,c(2:12,15)])

#cor_f <-cor(filtered_wines_w[13],filtered_wines_w[,c(2:13,15)])

rel_cor <- cor_all[,abs(cor_all) > 0.15]

rel_cor[order(abs(rel_cor), decreasing = TRUE)]
```

Even the +/-sign of correlation agrees with the sign of filtering (above or below a given value). This might be a coincidence. Except for alcohol (and perhaps density) to correlations are quite weak. 

On the other hand, the aim of filtering is to remove low quality wines, which dominate the distribution. Therefore even variables with relativelly low correlation with quality, could be good candidates for filtrering.

I also looked at the corellation between these variables:

```{r echo=FALSE}
mn <- names(rel_cor)
cor(wines_w[, mn])
```

Alcohol and density show a very strong correlation. Density is moderately correlated with total.sulfur.dioxide. The correlation between alcohol and total total.sulfur.dioxide is a bit weaker.

# Bivariate Analysis

### Talk about some of the relationships you observed in this part of the \
investigation. How did the feature(s) of interest vary with other features in \
the dataset?

I have plotted variables against quality and mostly confirmed the insight from box plots.

What I found quite interesting is that correlation coefficients (with wine quality) quite clearly pointed to the same variables I identified via box plots analysis. This makes sense for variables showing strong correlation. But even variables with weak correlation (bellow 0.2) can be used for filtering.

The correlation coefficients allowed me to judge the strength  of correlations. Alcohol has the strongest correlation with quality (0.44). Density comes next with -0.31.

### Did you observe any interesting relationships between the other features \
(not the main feature(s) of interest)?

Alcohol and density show a very strong correlation (-0.78). Density is moderately correlated with total.sulfur.dioxide (0.53). The correlation between alcohol and total total.sulfur.dioxide is a bit weaker (-0.45).

### What was the strongest relationship you found?

The negative correlation between alcohol and density is clearly the strongest one.

# Multivariate Plots Section

I started with plotting the variable pairings identified in the previous section. I have removed the outliers (lying outside of the IQR) and scaled the axes to focus on the majority of data points. I have also customized the alpha value, decreasing alpha for medium (forming the overwhelming majority) and increasing the alpha for bad and excellent wines (which are rare).

The plots confirm trends I already know: e.i. high alcohol and low density wines tend to have higher quality. However bad quality wines are scattered all over the plot.  

```{r echo=FALSE}
plot_bivar <- function(var1, var2, data1 = wines_w, show_leg = FALSE, remove_outliers = TRUE){
  p1 <- ggplot(aes(x = var1 , y = var2),
                    data= data1)+
               geom_point(aes(color = rating, alpha = rating))+
               #geom_point(aes(size = (alcohol -10)*2), alpha = alpha1, position = position_jitter(h=0))+
               #only use the part after $
               xlab(strsplit(deparse(substitute(var1)),"\\$")[[1]][2])+
               ylab(strsplit(deparse(substitute(var2)),"\\$")[[1]][2])+
               scale_alpha_manual(values = c(0.7,0.2,0.4,0.7))
  
  if(remove_outliers){
    #calculate IQRs
    iqr1 <- IQR(var1)
    md1 <- median(var1)
    r1 <- c(md1- 2*iqr1, md1+ 2*iqr1)

    iqr2 <- IQR(var2)
    md2 <- median(var2)
    r2 <- c(md2- 2*iqr2, md2+ 2*iqr2)
  
    #p1<- p1+coord_cartesian(xlim = r1, ylim = r2)
    
    #strangely not the same result as the commented line above!
    p1<- p1+coord_cartesian(xlim = r1)
    p1<- p1+coord_cartesian(ylim = r2)
  }
  
  if(!show_leg){
    p1<-p1+theme(legend.position="none")
  }
  
  return(p1)
}
```


```{r echo=FALSE}
plot_bivar(wines_w$alcohol, wines_w$density, remove_outliers = TRUE)#+
  #coord_cartesian(xlim = c(8.0,9.0), ylim = c(0.99,1.005))
  #coord_cartesian(xlim = c(12.5,14.5), ylim = c(0.985,0.995))

plot_bivar(wines_w$alcohol, wines_w$total.sulfur.dioxide)

plot_bivar(wines_w$alcohol, wines_w$chlorides)

plot_bivar(wines_w$volatile.acidity, wines_w$ratio.sulfur.dioxide)+
  coord_cartesian(xlim = c(0.1,0.6))


plot_bivar(wines_w$density, wines_w$total.sulfur.dioxide)+
  coord_cartesian(xlim = c(0.988,1.001), ylim = c(50,250))

plot_bivar(wines_w$density, wines_w$chlorides)+
  coord_cartesian(xlim = c(0.988,1.001), ylim = c(0.01, 0.075))
```

The plots are still very noisy and dominated by medium wines (green). Next I decided to focus only on filtered wines. I will repeat the same analysis as before. First I calculate Pearson's R between quality and other variables, this time considering only the filtered wines.

```{r echo=FALSE}
cor_f <-cor(filtered_wines_w[13],filtered_wines_w[,c(2:12,15)])
cor_f <-cor_f[,abs(cor_f)>0.00]

cor_f[order(abs(cor_f), decreasing = TRUE)]
```

The resulting list is very different from the one for all wines described previously.

```{r echo=FALSE}
rel_cor[order(abs(rel_cor), decreasing = TRUE)]
```

There are very few similarities in the two lists. In both alcohol shows the strongest correlation with quality. For filtered wines the difference between alcohol and the second best variable (residual sugar) is very small, in contrast to the other list.

Accidentally both list have three entries with correlation above 0.2 (in absolute terms). But for filtered wines the correlation drops much quicker. I start with the top three variables for filtered wines (alcohol, residual.sugar, total.sulfur.dioxide) against each other.

```{r echo=FALSE}

plot_bivar(filtered_wines_w$residual.sugar, filtered_wines_w$total.sulfur.dioxide,
           data = filtered_wines_w)

plot_bivar(filtered_wines_w$alcohol, filtered_wines_w$residual.sugar,
           data = filtered_wines_w)+
  coord_cartesian(ylim = c(0,8.0))


plot_bivar(filtered_wines_w$alcohol, filtered_wines_w$total.sulfur.dioxide,
           data = filtered_wines_w)
```

The plot of residual.sugar against total.sulfur.dioxide reveals an area dominated by good and excellent wines (where residual sugar is between 3 and 9). Next I will zoom into this section of the plot. I will also visualize two additional variables through size and shape.

In plot below size corresponds to alcohol and shape to pH. I have tried different combinations of variables, but I couldn't find a combination which reliably discriminates between good, medium and excellent wines. On the contrary, I have established that medium and excellent wines can be very similar  (examples plotted against a red background).

```{r echo=FALSE}
  var1 <- filtered_wines_w$residual.sugar
  var2 <- filtered_wines_w$total.sulfur.dioxide

  p1 <- ggplot(aes(x = var1, y = var2),
                    data= filtered_wines_w)
  
  p1 <- p1 + annotate("rect", xmin = 8, ymin = 105, xmax = 8.5, ymax = 120,
                      fill = "red", alpha = 0.2)
  
  p1 <- p1 + annotate("rect", xmin = 3.35, ymin = 85, xmax = 3.75, ymax = 100,
                      fill = "red", alpha = 0.2)
  
  p1 <- p1 + annotate("rect", xmin = 4.4, ymin = 130, xmax = 4.85, ymax = 147,
                      fill = "red", alpha = 0.2)
  
  p1 <- p1 + geom_point(aes(color = rating, alpha = rating, size = alcohol,
                              shape = cut(pH, breaks = 6)))+
               xlab("residual.sugar")+
               ylab("total.sulfur.dioxide")+
               scale_alpha_manual(values = c(0.7,0.2,0.4,0.7))+
               scale_size(range = c(1,6))+
               labs(shape="pH (level)")
                
  
  #calculate IQRs
  iqr1 <- IQR(var1)
  md1 <- median(var1)
  r1 <- c(md1- 2*iqr1, md1+ 2*iqr1)

  iqr2 <- IQR(var2)
  md2 <- median(var2)
  r2 <- c(md2- 2*iqr2, md2+ 2*iqr2)
  
  #strangely the plot for 
  #p1<- p1+coord_cartesian(xlim = r1, ylim = r2)
    
  #is different from the plot
  #p1<- p1+coord_cartesian(xlim = r1)
  #p1<- p1+coord_cartesian(ylim = r2)
  
  p_final <- p1+coord_cartesian(xlim = c(3.0,9.0))

  p_final
```


# Multivariate Analysis

### Talk about some of the relationships you observed in this part of the \
investigation. Were there features that strengthened each other in terms of \
looking at your feature(s) of interest?

Once again I have mostly confirmed trends from my previous investigation.

It was very interesting to see how the importance of features has changed, when I have considered only the filtered wines. In hindsight, it was to be expected. When I removed many wines based on a particular variable, one could expect that this variable will become less important in the remaining wines.

Yet I found the extent of this surprising. Density and chlorides are the features least correlate with quality in the filtered dataset. Prior to filtering, they were the most correlated features (after alcohol).

The plot below nicely shows the difference between the two data sets. The plot for all wines shows a linear tendency, while the plot for filtered wines is more scattered.

```{r echo=FALSE}
p0 <- plot_bivar(wines_w$alcohol, wines_w$density, show_leg = FALSE)
p0 <- p0 + ggtitle("All wines [vs density]")


p1 <- plot_bivar(filtered_wines_w$alcohol, filtered_wines_w$residual.sugar,
           data = filtered_wines_w, show_leg = FALSE)+
  coord_cartesian(xlim = c(8,14), ylim = c(0.0,7.5))
p1 <- p1 + ggtitle("Filtered wines [vs residual.sugar]")


grid.arrange(p0, p1, ncol=1, top = "Strongest correlations")
```


It is remarkable how strongly alcohol correlates with quality. I would be curious to know whether this is because of poor quality wines have little alcohol. Or because the high alcohol content numbs the finer distinctions between the wines.

### Were there any interesting or surprising interactions between features?

I was curious whether I can find simple criterion to reliably tell apart medium, good and excellent wines. I couldn't fine one. It was really interesting to see how very similar are two wines which significantly differ in quality.

The author of [1] have applied a number of machine learning techniques and came to a similar conclusion:

*In general, the white [wine] data results are better: 60.3/63.3% for classes 6 and 4, 67.8/72.6% for grades 7 and 5, and a surprising 85.5% for the class 8 (the exception are the 3 and 9 extremes with 0%, not shown in the table).*

Note that grade 6 wines represent 44.88% of distribution and are detected  in 60.3% of cases. Grade 5 wines represent 29.75% and are detected in 72.6%. Grade 7 wines represent 17.97% and are detected in 67.8%.

In summary for 92.6% wines the detection accuracy is just above 2/3. This suggests that reliably separating wines by quality is not easy.

### OPTIONAL: Did you create any models with your dataset? Discuss the \
strengths and limitations of your model.

I choose to create no models. The main reason is that quality (the target variable) is ultimately a factor variable, albeit expressed on a numeric scale. Ultimately it is a subjective judgement of three juror on a limited scale.

Base on my investigation I am sceptical about finding an objective and universal relationship between the measured variables and assigned quality. The findings reported in [1] reinforce my scepticism.

------

# Final Plots and Summary

> **Tip**: You've done a lot of exploration and have built up an understanding
of the structure of and relationships between the variables in your dataset.
Here, you will select three plots from all of your previous exploration to
present here as a summary of some of your most interesting findings. Make sure
that you have refined your selected plots for good titling, axis labels (with
units), and good aesthetic choices (e.g. color, transparency). After each plot,
make sure you justify why you chose each plot by describing what it shows.

### Plot One
```{r echo=FALSE, Plot_One}
p1 <- plot_vs_quality(wines_w$chlorides)
p1 <- p1 + geom_hline(yintercept = 0.037, color = "blue", linetype="dotted")

p2 <- plot_vs_quality(wines_w$ratio.sulfur.dioxide)
p2 <- p2 + geom_hline(yintercept = 0.2717, color = "blue", linetype="dotted")

p3 <- plot_vs_quality(wines_w$density)
p3 <- p3 + geom_hline(yintercept = 0.9918, color = "blue", linetype="dotted")

p4 <- plot_vs_quality(wines_w$alcohol)
p4 <- p4 + geom_hline(yintercept = 11.0, color = "blue", linetype="dotted")


grid.arrange(p1, p2, p3, p4, ncol=2)
```

### Description One


### Plot Two
```{r echo=FALSE, Plot_Two}
#filter_data(quote(wines_w$chlorides<0.037),verbose = TRUE)

#before filtering
p0 <-quality_bar("All")

draw_siluette = TRUE

#filter chlorides <0.037 <0.0355
filtered_wines_w<-filter_data(quote(chlorides<0.037))
fw<-filter_data(quote(chlorides<0.037))
p1 <- quality_bar("Chlorides", fw, show_all_hist = draw_siluette)

#filter ratio.sulfur.dioxide>0.2717
filtered_wines_w<-filter_data(quote(ratio.sulfur.dioxide>0.2717), data = filtered_wines_w)
fw<-filter_data(quote(ratio.sulfur.dioxide>0.2717))
p2 <- quality_bar("Sulf Ratio", fw, show_all_hist = draw_siluette)

#filter density <0.9918 0.9916
filtered_wines_w <-filter_data(quote(density<0.9918), data = filtered_wines_w)

fw<-filter_data(quote(density<0.9918))

p3 <- quality_bar("Density", fw, show_all_hist = draw_siluette)

p4 <- quality_bar("Filtered", fw, show_all_hist = draw_siluette)


grid.arrange(p0, p1, p2, p3, p4, ncol=2)
```



### Description Two


### Plot Three
```{r echo=FALSE, Plot_Three}
  var1 <- filtered_wines_w$residual.sugar
  var2 <- filtered_wines_w$total.sulfur.dioxide

  p1 <- ggplot(aes(x = var1, y = var2),
                    data= filtered_wines_w)
  
  p1 <- p1 + annotate("rect", xmin = 8, ymin = 105, xmax = 8.5, ymax = 120,
                      fill = "red", alpha = 0.2)
  
  p1 <- p1 + annotate("rect", xmin = 3.35, ymin = 85, xmax = 3.75, ymax = 100,
                      fill = "red", alpha = 0.2)
  
  p1 <- p1 + annotate("rect", xmin = 4.4, ymin = 130, xmax = 4.85, ymax = 147,
                      fill = "red", alpha = 0.2)
  
  p1 <- p1 + geom_point(aes(color = rating, alpha = rating, size = alcohol,
                              shape = cut(pH, breaks = 6)))+
               xlab("residual.sugar")+
               ylab("total.sulfur.dioxide")+
               scale_alpha_manual(values = c(0.7,0.2,0.4,0.7))+
               scale_size(range = c(1,6))+
               labs(shape="pH (level)")
                
  
  #calculate IQRs
  iqr1 <- IQR(var1)
  md1 <- median(var1)
  r1 <- c(md1- 2*iqr1, md1+ 2*iqr1)

  iqr2 <- IQR(var2)
  md2 <- median(var2)
  r2 <- c(md2- 2*iqr2, md2+ 2*iqr2)
  
  #strangely the plot for 
  #p1<- p1+coord_cartesian(xlim = r1, ylim = r2)
    
  #is different from the plot
  #p1<- p1+coord_cartesian(xlim = r1)
  #p1<- p1+coord_cartesian(ylim = r2)
  
  p1 <- p1+coord_cartesian(xlim = c(3.0,9.0))

  p1
  
#1] "alcohol"              "residual.sugar"       "total.sulfur.dioxide" "pH"                  
# [5] "free.sulfur.dioxide"  "sulphates"            "volatile.acidity"     "ratio.sulfur.dioxide"
# [9] "fixed.acidity"        "citric.acid"          "chlorides"            "density"
```

### Description Three

------

# Reflection

> **Tip**: Here's the final step! Reflect on the exploration you performed and
the insights you found. What were some of the struggles that you went through?
What went well? What was surprising? Make sure you include an insight into
future work that could be done with the dataset.

> **Tip**: Don't forget to remove this, and the other **Tip** sections before
saving your final work and knitting the final report!

# References

[1] P. Cortez, A. Cerdeira, F. Almeida, T. Matos and J. Reis. Modeling wine preferences by data mining from physicochemical properties. In Decision Support Systems, Elsevier, 47(4):547-553. ISSN: 0167-9236.
